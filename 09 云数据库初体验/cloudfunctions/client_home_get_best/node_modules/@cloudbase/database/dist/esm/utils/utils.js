import { EJSON } from 'bson';
import { isObject, isArray, isInternalObject } from './type';
import { SYMBOL_GEO_POINT, SYMBOL_GEO_LINE_STRING, SYMBOL_GEO_POLYGON, SYMBOL_GEO_MULTI_POINT, SYMBOL_GEO_MULTI_LINE_STRING, SYMBOL_GEO_MULTI_POLYGON, SYMBOL_UPDATE_COMMAND, SYMBOL_QUERY_COMMAND, SYMBOL_LOGIC_COMMAND, SYMBOL_SERVER_DATE, SYMBOL_REGEXP } from '../helper/symbol';
export const sleep = (ms = 0) => new Promise(r => setTimeout(r, ms));
const counters = {};
export const autoCount = (domain = 'any') => {
    if (!counters[domain]) {
        counters[domain] = 0;
    }
    return counters[domain]++;
};
export const getReqOpts = (apiOptions) => {
    if (apiOptions.timeout !== undefined) {
        return {
            timeout: apiOptions.timeout
        };
    }
    return {};
};
export const stringifyByEJSON = params => {
    return EJSON.stringify(params, { relaxed: false });
};
export const parseByEJSON = params => {
    return EJSON.parse(params);
};
export class TcbError extends Error {
    constructor(error) {
        super(error.message);
        this.code = error.code;
        this.message = error.message;
    }
}
export const E = (errObj) => {
    return new TcbError(errObj);
};
const GRAY_ENV_KEY = 'TCB_SDK_GRAY_0';
const needTransformFunc = ['update', 'set', 'create', 'add'];
export const preProcess = () => {
    return function (_target, propertyKey, descriptor) {
        let newFunc = descriptor.value;
        descriptor.value = async function () {
            const oldInstance = this._oldInstance;
            const oldFunc = oldInstance[propertyKey];
            if (this._db && this._db.config) {
                const { _useFeature } = this._db.config;
                if (_useFeature === true) {
                    return newFunc.apply(this, arguments);
                }
            }
            try {
                if (process.env.TCB_CONTEXT_CNFG) {
                    const grayEnvKey = JSON.parse(process.env.TCB_CONTEXT_CNFG);
                    if (grayEnvKey[GRAY_ENV_KEY] === true) {
                        return newFunc.apply(this, arguments);
                    }
                }
            }
            catch (e) {
                console.log('parse context error...');
            }
            if (needTransformFunc.indexOf(propertyKey) >= 0) {
                return oldFunc.call(oldInstance, transformDbObjFromNewToOld(arguments[0], oldInstance._db, [arguments[0]]));
            }
            return oldFunc.apply(oldInstance, arguments);
        };
    };
};
export function processReturn(throwOnCode, res) {
    if (throwOnCode === false) {
        return res;
    }
    throw E(Object.assign({}, res));
}
export function transformDbObjFromNewToOld(val, oldDb, visited) {
    if (isInternalObject(val)) {
        switch (val._internalType) {
            case SYMBOL_GEO_POINT: {
                const { longitude, latitude } = val;
                return new oldDb.Geo.Point(longitude, latitude);
            }
            case SYMBOL_GEO_MULTI_POINT: {
                const { points } = val;
                const transformPoints = points.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                return new oldDb.Geo.MultiPoint(transformPoints);
            }
            case SYMBOL_GEO_LINE_STRING: {
                const { points } = val;
                const transformPoints = points.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                return new oldDb.Geo.LineString(transformPoints);
            }
            case SYMBOL_GEO_MULTI_LINE_STRING: {
                const { lines } = val;
                const transformLines = lines.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                return new oldDb.Geo.MultiLineString(transformLines);
            }
            case SYMBOL_GEO_POLYGON: {
                const { lines } = val;
                const transformLines = lines.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                return new oldDb.Geo.Polygon(transformLines);
            }
            case SYMBOL_GEO_MULTI_POLYGON: {
                const { polygons } = val;
                const transformPolygons = polygons.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                return new oldDb.Geo.MultiPolygon(transformPolygons);
            }
            case SYMBOL_SERVER_DATE: {
                const { offset } = val;
                return new oldDb.serverDate({ offset });
            }
            case SYMBOL_REGEXP: {
                const { $regularExpression: { options, pattern } } = val;
                return new oldDb.RegExp({ regexp: pattern, options });
            }
            case SYMBOL_UPDATE_COMMAND: {
                const { operator, operands } = val;
                let transformOperands;
                if (isArray(operands)) {
                    transformOperands = operands.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                }
                else {
                    transformOperands = transformDbObjFromNewToOld(operands, oldDb, [...visited, operands]);
                }
                return new oldDb.updateCommand(operator, transformOperands);
            }
            case SYMBOL_QUERY_COMMAND: {
                const { operator, operands } = val;
                let transformOperands;
                if (isArray(operands)) {
                    transformOperands = operands.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                }
                else {
                    transformOperands = transformDbObjFromNewToOld(operands, oldDb, [...visited, operands]);
                }
                return new oldDb.queryCommand(operator, transformOperands);
            }
            case SYMBOL_LOGIC_COMMAND: {
                const { operator, operands } = val;
                let transformOperands;
                if (isArray(operands)) {
                    transformOperands = operands.map(item => transformDbObjFromNewToOld(item, oldDb, [...visited, item]));
                }
                else {
                    transformOperands = transformDbObjFromNewToOld(operands, oldDb, [...visited, operands]);
                }
                return new oldDb.logicCommand(operator, transformOperands);
            }
        }
    }
    else if (isArray(val)) {
        return val.map(item => {
            if (visited.indexOf(item) > -1) {
                throw new Error('Cannot convert circular structure to JSON');
            }
            return transformDbObjFromNewToOld(item, oldDb, [...visited, item]);
        });
    }
    else if (isObject(val)) {
        const rawRet = Object.assign({}, val);
        const finalRet = {};
        for (const key in rawRet) {
            if (visited.indexOf(rawRet[key]) > -1) {
                throw new Error('Cannot convert circular structure to JSON');
            }
            finalRet[key] = transformDbObjFromNewToOld(rawRet[key], oldDb, [...visited, rawRet[key]]);
        }
        return finalRet;
    }
    else {
        return val;
    }
}
